#define _DEFAULT_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>
#include <fcntl.h>
#include <termios.h>
#include <unistd.h>

// full parameter file data structure as of 2018/07/16
// Full parameters payload
struct full_prm_t
{
    /*0000..0005*/ char           Reserved0[6];              // Резерв
    /*0006..0007*/ unsigned short Period_Oleg;               // Read-Only
    /*0008..0009*/ unsigned short cnt_Oleg;                  // Read-Only
    /*0010..0011*/ short          T_Nominal_0;               // Номинальная температура термодатчика ДУС Х
    /*0012..0013*/ unsigned short A_abs;                     // Признак отключения по абсолютному/горизонтальному ускорению
    /*0014..0015*/ unsigned short cor_A;                     // Тип азимутальной коррекции
    /*0016..0017*/ unsigned short cor_G;                     // Тип горизонтальной коррекции
    /*0018..0019*/ unsigned short Period;                    // Частота выдачи данных
    /*0020..0021*/ unsigned short ptnv;                      // Время начальной выставки
    /*0022..0057*/ float          R_cp[3][3];                // Калибровочная матрица ДУС (рассчитанная)
    /*0058..0093*/ float          P_c[3][3];                 // Матрица ДУС учета дрейфа от g (рассчитанная)
    /*0094..0105*/ float          Uw00[3];                   // Вектор смещения нулей ДУС
    /*0106..0141*/ float          K_cp[3][3];                // Калибровочная матрица акселерометров (рассчитанная)
    /*0142..0153*/ float          Ua00[3];                   // Вектор смещения нулей акселерометров
    /*0154..0189*/ float          M_cp[3][3];                // Калибровочная матрица магнитометров (рассчитанная)
    /*0190..0201*/ float          Um00[3];                   // Вектор смещения нулей магнитометров
    /*0202..0205*/ float          kG;                        // Коэффициент пропорциональной коррекции в горизонте
    /*0206..0209*/ float          wcG_max;                   // Коэффициент постоянной коррекции в горизонте
    /*0210..0213*/ float          kA;                        // Коэффициент пропорциональной коррекции в азимуте
    /*0214..0217*/ float          wcA_max;                   // Коэффициент постоянной коррекции в азимуте
    /*0218..0221*/ float          Latitude;                  // Широта
    /*0222..0225*/ float          Ta_cut_1;                  // Постоянная времени 1 фильтра акселерометров
    /*0226..0229*/ float          Ta_cut_2;                  // Постоянная времени 2 фильтра акселерометров
    /*0230..0233*/ float          Tm_cut_1;                  // Постоянная времени 1 фильтра магнитометров
    /*0234..0237*/ float          Tm_cut_2;                  // Постоянная времени 2 фильтра магнитометров
    /*0238..0241*/ float          A_cut;                     // Порог отключения коррекции по акселерометрам
    /*0242..0245*/ float          M_cut;                     // Порог отключения коррекции по магнитометрам
    /*0246..0249*/ float          kGi;                       // Коэффициент интегральной коррекции в горизонте
    /*0250..0253*/ float          kAi;                       // Коэффициент интегральной коррекции в азимуте
    /*0254..0257*/ float          STDw;                      // СКО шума ДУС
    /*0258..0261*/ float          Sw;                        // СКО порождающего белого шума ДУС
    /*0262..0265*/ float          STDa;                      // СКО шума акселерометров
    /*0266..0269*/ float          STDk;                      // СКО шума магнитометров
    /*0270..0273*/ float          e0;                        // Коэффициент коррекции для ОФК
    /*0274..0309*/ float          B_c[3][3];                 // Матрица ДУС учета дрейфа от g (заданная)
    /*0310..0333*/ float          ga1[2][3];                 // Матрица линейной температурной коррекции нулей ДУС
    /*0334..0357*/ float          ga2[2][3];                 // Матрица линейной температурной коррекции МК ДУС
    /*0358..0381*/ float          aa1[2][3];                 // Матрица линейной температурной коррекции нулей акселерометров
    /*0382..0405*/ float          aa2[2][3];                 // Матрица линейной температурной коррекции МК акселерометров
    /*0406..0429*/ float          ma1[2][3];                 // Матрица линейной температурной коррекции нулей магнитометров
    /*0430..0453*/ float          ma2[2][3];                 // Матрица линейной температурной коррекции МК магнитометров
    /*0454..0465*/ float          K_cm0[3];                  // Вектор номинальных МК акселерометров
    /*0466..0469*/ unsigned int   ClbMagDispThreshold;       // Mag. field clb cut threshold (nT^2)
    /*0470..0481*/ float          R_cm0[3];                  // Вектор номинальных МК ДУС
    /*0482..0497*/ short          T_Nominal_1_8[8];          // Номинальная температура всех термодатчиков (кроме ДУС Х)
    /*0498..0509*/ float          M_cm0[3];                  // Вектор номинальных МК магнитометров
    /*0510..0545*/ float          Tm_c[3][3];                // Калибровочная матрица магнитометров учета магнитных возмущений
    /*0546..0557*/ float          Hm0[3];                    // Вектор смещений нулей магнитометров учета магнитных возмущений
    /*0558..0561*/ float          Mdec;                      // Магнитное склонение
    /*0562..0565*/ float          Longitude;                 // Долгота
    /*0566..0569*/ float          Altitude;                  // Высота
    /*0570..0581*/ float          AlAngles[3];               // Углы привязки «Pointer» к устанавливаемому устройству
    /*0582..0585*/ float          Mdec_date;                 // Время
    /*0586..0589*/ float          SFG;                       // МК для термодатчиков ДУС
    /*0590..0593*/ float          BiasG;                     // Смещение нулей для термодатчиков ДУС
    /*0594..0597*/ float          SFA;                       // МК для термодатчиков акселерометров
    /*0598..0601*/ float          BiasA;                     // Смещение нулей для термодатчиков акселерометров
    /*0602..0605*/ float          SFM;                       // МК для термодатчиков магнитометров
    /*0606..0609*/ float          BiasM;                     // Смещение нулей для термодатчиков магнитометров
    /*0610..0617*/ char           Device_Name[8];            // Имя устройства
    /*0618..0621*/ float          A_cut_dr_est;              // Порог по ускорениям для отключения оценивания дрейфов ДУСов при CE кор
    /*0622..0625*/ float          M_cut_dr_est;              // Порог по магн.возм. для отключения оценивания дрейфов ДУСов при CE кор.
    /*0626..0629*/ float          gainG;                     // Коэффициент усиления наблюдателя в CE коррекции (горизонтальный канал)
    /*0630..0633*/ float          gainA;                     // Коэффициент усиления наблюдателя в CE коррекции (азимутальный канал)
    /*0634..0637*/ float          T_begin_est;               // Время начала осреднения оценок ДУС в наблюдателе при CE коррекции
    /*0638..0641*/ float          T_est;                     // Время оценивания дрейфа ДУС в наблюдателе при CE коррекции
    /*0642..0642*/ unsigned char  MultiType;                 // Кратность увеличения частоты интегрирования кватерниона по отношению к частоте вычислений. Начиная с версии  4.9.6.1 в прошивке не используется
    /*0643..0643*/ unsigned char  Fadc;                      // Кратность увеличения частоты съема данных по отношению к частоте вычислений
    /*0644..0644*/ unsigned char  DeviceType;                // Device type
    /*0645..0645*/ unsigned char  Estimator;                 // При Estimator=1 в прошивке работает наблюдатель (как раньше в CE), при Estimator=0 наблюдатель отключен
    /*0646..0649*/ float          T_f;                       // Постоянная времени фильтра для ДУС и акселерометров в режиме awake
    /*0650..0653*/ float          ksi;                       // Коэфф. демпфирования фильтра для ДУС и акселерометров в режиме awake
    /*0654..0654*/ unsigned char  Multi_Modes;               // Включить (1) / выключить (0) работу Указки в мультирежиме
    /*0655..0655*/ unsigned char  sensorsSet;                // Тип набора датчиков
    /*0656..0657*/ unsigned short t_delay_fa;                // Время (в тактах) задержки выхода из full режима в awake
    /*0658..0659*/ unsigned short t_delay_as;                // Время (в тактах) задержки выхода из awake режима в sleep
    /*0660..0661*/ short          T_limit_minsw;             // Значение угла тангажа (-), при котором происходит переключение из режима awake в full
    /*0662..0663*/ unsigned short T_limit_maxsw;             // Значение угла тангажа (+), при котором происходит переключение из режима awake в full
    /*0664..0664*/ unsigned char  G_limitsw;                 // Значение угла крена, при котором происходит переключение из режима awake в full
    /*0665..0665*/ unsigned char  BIff;                      // Частота фильтра сглаживания, Hz*100
    /*0666..0669*/ float          koef_otkl;                 // Коэффициент увеличения пороговых углов тангажа и крена для перехода из режима FULL в AWAKE
    /*0670..0671*/ unsigned short T_limit_sleepsw;           // Значение угла тангажа, при котором происходит переключение из режима awake в sleep
    /*0672..0673*/ unsigned short G_limit_sleepsw;           // Значение угла крена, при котором происходит переключение из режима awake в sleep
    /*0674..0675*/ unsigned short delta_UaksY;               // Допустимое отклонение сырых данных акселерометра Y для выхода из режима sleep
    /*0676..0677*/ unsigned short time_average;              // Время в тактах для расчета скользящей дисперсии
    /*0678..0681*/ float          D_aks;                     // Порог дисперсии акселерометров для переключения режима Awake
    /*0682..0682*/ unsigned char  Shot_detect;               // Вариант детектирования выстрела
    /*0683..0683*/ unsigned char  W_type;                    // Тип оружия
    /*0684..0685*/ unsigned short ClbInclinationThreshold;   // Mag. field calb inclination threshold (deg) * 100
    /*0686..0697*/ float          Acc_lim[3];                // Массив из 3-х порогов для акселерометров при определении dry shots
    /*0698..0705*/ float          DUS_lim[2];                // Массив из 2-х порогов для ДУСов при определении dry shots
    /*0706..0707*/ unsigned short shot_lock_time;            // Количество циклов когда выстрелы не детектируются
    /*0708..0709*/ unsigned short ClbSuccessThreshold;       // Mag. field calb success threshold (nT)
    /*0710..0713*/ float          Mag_abs_cut;               // Порог для отклонения текущего модуля МПЗ от измеренного при начальной выставке
    /*0714..0717*/ float          DUS_cut2;                  // Gyro threshold 1 (deg/s)
    /*0718..0718*/ unsigned char  CalibrType;                // Type of calibration performed (0 – WOM is not calibrated; 1 – WOM is calibrated by loading calibration parameters from outer software; 4  – zone-based calibration)
    /*0719..0719*/ unsigned char  ClbCount;                  // Number of used calibration points (1, …, 9)
    /*0720..0720*/ unsigned char  ClbSuccess;                // Calibration success (0 – calibration is not successful; 1 – calibration is successful)
    /*0721..0721*/ char           Reserved1;                 // Reserved byte in the GetClbRes command
    /*0722..0722*/ unsigned char  koef_Sigma_Acc;            // Коэффициент для порога отключения сигналов акселерометров в ОФК
    /*0723..0723*/ unsigned char  koef_Sigma_Mag;            // Коэффициент для порога отключения сигналов магнитометров в ОФК
    /*0724..0731*/ float          TargetOffsets[2];          // Углы смещения, град
    /*0732..0732*/ unsigned char  N_ma;                      // Количество точек для вычисления скользящего среднего по сигналам гироскопов
    /*0733..0738*/ short          ro[3];                     // Расстояния от центра качания объекта до места установки Указки в осях объекта, метры*100
    /*0739..0739*/ unsigned char  T1aa;                      // Постоянная времени полосового фильтра для дифференцирования сигналов ДУС, секунды*100
    /*0740..0743*/ float          DUS_p;                     // Порог по ДУСам при котором отключается компенсация ускорений при качке, град/сек
    /*0744..0744*/ unsigned char  toff;                      // Задержка по времени на отключение компенсации ускорений при качке, секунды
    /*0745..0768*/ float          gpoly1[2][3];              // Матрица полиномиальной температурной коррекции нулей ДУС
    /*0769..0792*/ float          gpoly2[2][3];              // Матрица полиномиальной температурной коррекции МК ДУС
    /*0793..0816*/ float          apoly1[2][3];              // Матрица полиномиальной температурной коррекции нулей акселерометров
    /*0817..0840*/ float          apoly2[2][3];              // Матрица полиномиальной температурной коррекции МК акселерометров
    /*0841..0864*/ float          mpoly1[2][3];              // Матрица полиномиальной температурной коррекции нулей магнитометров
    /*0865..0888*/ float          mpoly2[2][3];              // Матрица полиномиальной температурной коррекции МК магнитометров
    /*0889..0889*/ unsigned char  ThermoCompType;            // Тип температурной коррекции
    /*0890..0891*/ unsigned short dDUS_lim;                  // Angular acceleration threshold, deg/sec^2
    /*0892..0893*/ unsigned short dMag_lim;                  // Mag. field increment threshold, nT
    /*0894..0895*/ unsigned short dMag2_lim;                 // Mag. field 2nd increment threshold, nT
    /*0896..0899*/ float          DUS_cut1;                  // Gyro threshold 2 (deg/s)
    /*0900..0903*/ float          Td_cut_HP;                 // Time constant 1 of gyro BP filter (sec)
    /*0904..0907*/ float          Td_cut_LP;                 // Time constant 2 of gyro BP filter (sec)
    /*0908..0909*/ unsigned short t_delay_af;                // Время (в тактах) задержки выхода из awake режима в full
    /*0910..0911*/ unsigned short T_Wdr;                     // Gyro drift estimator: Filter time constant (sec)
    /*0912..0913*/ unsigned short dt_GE;                     // Gyro drift estimator: Heading change time (sec * 100)
    /*0914..0917*/ float          dK_id_GE;                  // Gyro drift estimator: Heading threshold (deg)
    /*0918..0919*/ unsigned short dI_cut;                    // Relative inclination threshold * 1000
    /*0920..0920*/ unsigned char  T_H;                       // Постоянная времени фильтра гориз. составляющей МПЗ (сек * 10)
    /*0921..0921*/ unsigned char  PR_treshold_LC;            // Порог по крену и тангажу при детект. полного оборота в 3D клб.
    /*0922..0922*/ unsigned char  Az_Zone_min;               // Минимальный размер зоны по азимуту в зональной калибр. (град)
    /*0923..0923*/ unsigned char  P_Zone_min;                // Минимальный размер зоны по тангажу в зональной калибр. (град)
    /*0924..0924*/ unsigned char  Zone_ctr_lim;              // Радиус центра зоны в зональной калибр. (град)
    /*0925..0925*/ unsigned char  count_shock_max;           // Максимальное значение для счетчика count_shock
    /*0926..0926*/ unsigned char  R_Sun;                     // Sun_Tracker: радиус области вокруг Солнца (без биннинга)
    /*0927..0927*/ unsigned char  R_Star1;                   // Star_Tracker: минимальный радиус звезды
    /*0928..0928*/ unsigned char  R_Star2;                   // Star_Tracker: радиус фоновой области вокруг звезды
    /*0929..0929*/ unsigned char  IStar_min;                 // Star_Tracker: минимальное значение яркости звезды
    /*0930..0930*/ unsigned char  IStar_out_max;             // Star_Tracker: максимальное значение яркости фона неба вокруг пикселя звезды
    /*0931..0931*/ unsigned char  StarPredict;               // Star_Tracker: - вариант прогноза положения звезд на картинке
    /*0932..0933*/ unsigned short CornerX;                   // Sun_Tracker: задает угол на изображении для отбраковки кадров
    /*0934..0935*/ unsigned short CornerY;                   // Sun_Tracker: задает угол на изображении для отбраковки кадров
    /*0936..0936*/ unsigned char  CelestialVariant;          // Тип астроориентатора
    /*0937..0937*/ unsigned char  AutoStart;                 // Автоматический старт прибора при включении (0 – нет, при других значения это код команды с какой идет автостарт)
    /*0938..0938*/ unsigned char  SBAScontrol;               // Использовать спутники SBAS (0 = не использовать; 1 =AUTO; 2= ANY; 3=WAAS; 4=EGNOS; 5=MSAS; 6=GAGAN; 7=QZSS)
    /*0939..0939*/ unsigned char  GNSS_COM2_data_rate;       // Выдача сырых данных приемника СНС (0 – нет, 1 – да)
    /*0940..0942*/ unsigned char  GyroXYZ[3];                // Назначение осей ДУСов осям AHRS
    /*0943..0943*/ unsigned char  hk_ext;                    // Шаг экстраполяции углов ориентации(c*1000)
    /*0944..0944*/ unsigned char  no_data_avr;               // Запрет осреднения выходных данных AHRS: 0 – выходные данные AHRS осредняются как обычно; 1 – частота выдачи = частоте вычислений (для использования в ИНС и AHRS-II)
    /*0945..0945*/ unsigned char  COM1_bps;                  // Baud rate основного COM порта (0 – 4800, 1 – 9600, 2 – 14400, 3 – 19200, 4 – 38400, 5 – 57600, 6 – 115200,  7–230400, 8 –460800, 9 – 921600 bps)
    /*0946..0946*/ unsigned char  COM1_bps_ISON;             // Baud rate основного COM порта (0 – 4800, 1 – 9600, 2 – 14400, 3 – 19200, 4 – 38400, 5 – 57600, 6 – 115200,  7–230400, 8 –460800, 9 – 921600 bps)
    /*0947..0947*/ unsigned char  Mdec_AUTO;                 // Расчет  магнитного склонения во время работы INS (0 – Нет, 1 – Да)
    /*0948..0948*/ unsigned char  Accel_var;                 // Вариант акселерометра (0 – внутренний IMU, 1- ADXL355)
    /*0949..0949*/ unsigned char  Mag_var;                   // Вариант магнитометра (0 – внутренний IMU, 1- standalone, 2 – магнитометр отсутствует)
    /*0950..0951*/ unsigned short Mag_sn;                    // Серийный номер магнитометра
    /*0952..0952*/ unsigned char  Algorithm_type;            // Тип выбранного алгоритма ISON (0=Default, 1=INS, 2=AHRS-II, 3=MRU-B, 4=VG, 5=IMU, 6=VR)
    /*0953..0953*/ unsigned char  MRU_B1_data;               // Вариант выходных данных для разных MRU-B1(0 = Heave PR, 1 – нет углов Pitch & Roll,  есть Heave [Heave] ,  2 = есть углы Pitch & Roll, нет  Heave[PR]).
    /*0954..0954*/ unsigned char  h_bar_mode_change;         // 0 - разрешить, 1 - запретить, изменение h_bar_mode в Demo программах
    /*0955..0958*/ float          TdLP;                      // постоянная времени многоцелевого НЧ фильтра ДУСов
    /*0959..0962*/ float          DUS_LP_cut;                // порог отключения для многоцелевого НЧ фильтра ДУСов
    /*0963..0963*/ unsigned char  wcG_max_gain;              // коэффициент увеличения постоянной коррекции в горизонте
    /*0964..0964*/ unsigned char  wcA_max_gain;              // коэффициент увеличения постоянной коррекции в азимуте
    /*0965..0965*/ unsigned char  rotated_sensors;           // Измененная физически ориентация внешнего акселерометра ADXL355 и IMU 3020
    /*0966..0966*/ unsigned char  InitAlign_block_type;      // Тип формата блока начальной выставки: 0 – короткий формат (старый), 1 – расширенный формат.
    /*0967..0968*/ unsigned short NMEA_logs_COM2;            // Заказ логов NMEA приемника СНС по порту COM2 (GGA, GSA, RMC, VTG, ZDA).
    /*0969..0969*/ unsigned char  catapult_start;            // true для БПЛА, стартовавшего с катапульты, есть изменения в алгоритме ИНС
    /*0970..0970*/ unsigned char  A_catapult_cut;            // Пороговое ускорение при старте с катапульты, при котором перезапускается ИНС, (g*10)
    /*0971..0971*/ unsigned char  GNSS_type;                 // Тип системы: 0 – с приемником NovAtel, 1 – с приемником Tersus, 2 – с внешним приемником для Airobatics, 3 – Hemisphere, 4 – Unicore
    /*0972..0972*/ unsigned char  Stop_on_failure;           // Остановка прибора при отказе датчиков через 2 секунды (гироскопов, акселерометров, магнитометров)
    /*0973..0973*/ unsigned char  Gyro_Bandwidth;            // Полоса пропускания ДУС (в IMU3010) (0 – No, 1 – 10 Hz, 2 – 25 Hz, 3 – 50 Hz, 4 – 75 Hz, 5 – 100 Hz, 6 – 200 Hz)
    /*0974..0974*/ unsigned char  Accel_Bandwidth;           // Полоса пропускания акселерометров (зарезервироованно)
    /*0975..0975*/ unsigned char  Sensors_output_axes;       // 0 – сигналы всех датчиков в осях объекта; 1 – сигналы всех датчиков в осях ИНС/AHRS
    /*0976..0976*/ unsigned char  Sensors_output_var;        // Вариант выходных данных (0 – мгновенные угловые скорости и ускорения, 1 – осредненные угловые скорости и ускорения, 2 – приращение углов и скоростей).
    /*0977..0977*/ unsigned char  IMU_type;                  // Вариант IMU(auto  –  0,  IMU3020 -   1,  IMU3010 – 2, IMU3010_IL – 3,  OS3D  -  4, OS3D_ADC - 5, IMU3010_2k – 6)
    /*0978..0978*/ unsigned char  Fixed_data_rate;           // Разрешение на перерасчет кратной частоты выдачи данных(0 – НЕТ, 1- ДА)
    /*0979..0979*/ unsigned char  ProcPCB_type;              // Тип платы процессора: 0 – обычная плата ( MPC 0.4); 1 – плата М. Жукова версии MPC 2.1
    /*0980..0980*/ unsigned char  STD_PR_init;               // Нач. условия для эл-та матрицы P0 для ОФК AHRS-1  (град*100)
    /*0981..0981*/ unsigned char  STD_K_init;                // Нач. условия для эл-та матрицы P0 для ОФК AHRS-1  (град*100)
    /*0982..0982*/ unsigned char  IMUP_ODR;                  // ADXL355, 357 accelerometer Output Data Rate (1 – 125Hz, 2 – 250Hz, 3 – 500Hz, 4 – 1KHz, 5 – 2KHz, 0 – 2KHz for old parameters)
    /*0983..0983*/ unsigned char  IMUP_LPF_frq;              // ADXL355, 357 accelerometer LPF -3dB frequency (1 –16Hz, 2 – 33Hz, 3 –66Hz, 4 – 131Hz, 5 – 262Hz, 0 – 262Hz for old parameters)

    /*0984..1419*/ char           Reserved2[436];            // Резерв
    /*1420..1421*/ unsigned short T_LP_alt;                  // Постоянная времени ФНЧ для среднего значения высоты (сек*100)
    /*1422..1422*/ unsigned char  Heave_var;                 // Вариант расчета Heave (0 -  расчет  c ускорений акселерометров, 1 – расчет  с высоты)
    /*1423..1424*/ unsigned short STDk_aux;                  // СКО шума вспомогательного измерителя угла курса (град*100)
    /*1425..1425*/ unsigned char  Time_stamp_round;	         // Использование округленной или точной поправки меток времени (0 – округленная, 1 - точная ).
    /*1426..1427*/ short          Time_stamp_corr;           // Коррекция  меток времени (ms*1000)
    /*1428..1428*/ unsigned char  T0_heave;                  // Initial heave period (sec)
    /*1429..1430*/ unsigned short k_Sigma_coord_ext;         // Порог для квадратичной формы невязки по координатам
    /*1431..1432*/ unsigned short STD_Vv_ext;                // СКО шума измерения  при определении вертикальной скорости(m*100)
    /*1433..1434*/ unsigned short STD_h_ext;                 // СКО шума измерения при определении высоты в режиме(m*100)
    /*1435..1436*/ unsigned short STD_fi_la_ext;             // СКО шума измерения  при определении внешних координат  (m*100)
    /*1437..1442*/ short          ro_pv[3];                  // Положение расчетной точки для вычисления координат и скоростей относительно ИНС в осях объекта, (m*100)
    /*1443..1446*/ float          pulse_length;              // Цена деления одного импульса одометра (м)
    /*1447..1447*/ unsigned char  pulse_length_AUTO_clb;     // Автоматическая калибровка одометра во время работы INS
    /*1448..1453*/ short          ro_odom[3];                // Положение одометра относительно БИНС в осях объекта (m*100)
    /*1454..1454*/ unsigned char  Odometer_type;             // Работа системы с  одометром: (0) --  нет,  (1) – данные OBD-Link, (2) – данные энкодера
    /*1455..1455*/ unsigned char  P_w;                       // P_wind=diag([P_w; P_w; P_as0])*100   СКО начальной ошибки оценивания ветра и смещения нуля СВС, (м/с)
    /*1456..1456*/ unsigned char  P_as0;                     //
    /*1457..1460*/ float          Q_w;                       // Q_wind=diag([Q_w; Q_w; Q_as0]);   СКО порождающего шума оценки ветра и смещения нуля СВС, (м/с/с)
    /*1461..1464*/ float          Q_as0;                     //
    /*1465..1465*/ unsigned char  R_w;                       // СКО шума измерений, (м/с)*100
    /*1466..1466*/ unsigned char  COM1_Aiding_data;          // Использовать внешние данные, переданные по COM1, в алгоритме
    /*1467..1467*/ unsigned char  Ant_baseline_set;          // 0 – Использовать угловую ориентацию антенн относительно осей объекта для поправки угла курса 1 – Использовать позицию антенн относительно осей объекта для поправки угла курса
    /*1468..1469*/ short          Alpha_gps;                 // Угловая ориентация антенн относительно осей объекта для поправки угла курса
    /*1470..1471*/ short          Beta_gps;                  // Угловая ориентация антенн относительно осей объекта для поправки угла курса
    /*1472..1477*/ short          ro_gps_second[3];          // Положение второй СНС антенны относительно БИНС в осях объекта (m*100)
    /*1478..1479*/ unsigned short STD_Vh_rtk;                // СКО шума приемника СНС при определении горизонтальной скорости движения в режиме RTK  (m/s*1000)
    /*1480..1481*/ unsigned short STD_Vv_rtk;                // СКО шума приемника СНС при определении вертикальной  скорости движения в режиме RTK  (m/s*1000)
    /*1482..1483*/ unsigned short k_Sigma_coord_rtk;         // Порог для квадратичной формы невязки по координатам в режиме RTK
    /*1484..1485*/ unsigned short k_Sigma_V_rtk;             // Порог для квадратичной формы невязки по скоростям в режиме RTK
    /*1486..1487*/ unsigned short k_Sigma_Ku_rtk;            // Порог для квадратичной формы невязки по курсу в режиме RTK
    /*1488..1489*/ unsigned short k_Sigma_Ku2A_rtk;          // Порог для квадратичной формы невязки по курсу при использовании 2-х антенного приемника СНС в режиме RTK
    /*1490..1490*/ unsigned char  Altitude_var;              // Вариант высоты (0 – MSL, 1 – WGS84)
    /*1491..1491*/ unsigned char  GGA_data_rate;             // Частота выдачи лога GGA приемника СНС, Гц (0 – 1 Hz, 1 – 1Hz, 2 – 2Hz, 3 – 4Hz,4 – 5Hz, 5 – 10Hz, 6 – 20Hz)
    /*1492..1492*/ unsigned char  GSA_data_rate;             // Частота выдачи лога GSA приемника СНС, Гц (0 – 1 Hz, 1 – 1Hz, 2 – 2Hz, 3 – 4Hz,4 – 5Hz, 5 – 10Hz, 6 – 20Hz)
    /*1493..1493*/ unsigned char  RMC_data_rate;             // Частота выдачи лога RMC приемника СНС, Гц (0 – 1 Hz, 1 – 1Hz, 2 – 2Hz, 3 – 4Hz,4 – 5Hz, 5 – 10Hz, 6 – 20Hz)
    /*1494..1494*/ unsigned char  VTG_data_rate;             // Частота выдачи лога VTG приемника СНС, Гц (0 – 1 Hz, 1 – 1Hz, 2 – 2Hz, 3 – 4Hz,4 – 5Hz, 5 – 10Hz, 6 – 20Hz)
    /*1495..1495*/ unsigned char  ZDA_data_rate;             // Частота выдачи лога ZDA приемника СНС, Гц (0 – 1 Hz, 1 – 1Hz, 2 – 2Hz, 3 – 4Hz,4 – 5Hz, 5 – 10Hz, 6 – 20Hz)
    /*1496..1496*/ unsigned char  Sw_alpha;                  // Шум оценки угла рассогласования ?= Sw_alpha (deg/sec)*100
    /*1497..1497*/ unsigned char  Alpha_K_init;              // Нач.условия для эл-та матрицы P0[10][10]   (deg*10)
    /*1498..1498*/ unsigned char  Alpha_K_est;               // Флаг для включения или выключения оценки рассогласования углов в горизонтальном ОФК (0 – выкл. 1 – вкл.).
    /*1499..1499*/ unsigned char  ODOM_COM4_enabled;         // Вариант данных по COM4 (0) -- нет, (1) – принимать данные OBD-Link, (2) – выдавать GPRMC
    /*1500..1500*/ unsigned char  ODOM_COM4_data_rate;       // Частота данных по COM4 (0 – 1 Hz, 1 – 1Hz, 2 – 2Hz, 3 – 4Hz,4 – 5Hz, 5 – 10Hz, 6 – 20Hz, 7 – 50Hz)
    /*1501..1501*/ unsigned char  ODOM_COM4_bps;             // Baud rate COM4 порта который принимает поправки (0 – 115200, 1 – 9600, 2 – 19200, 3 – 38400, 4 – 57600, 5 – 115200 bps, 6– 230400 bps , 7 – 460800 bps)
    /*1502..1502*/ unsigned char  k_Sigma_V_ext;             // Порог для квадратичной формы невязки по скоростям одометра
    /*1503..1503*/ unsigned char  STD_Vh_ext;                // СКО шума приемника СНС при определении горизонтальной скорости движения (m/s*100)
    /*1504..1504*/ unsigned char  GNSS_COM3_data_set;        // Вариант выходных данных приемника СНC  по порту COM3:  (0 – нет данных; 1 – raw GNSS data set; 2 – GPRMC)
    /*1505..1505*/ unsigned char  HSS_res;                   // Числовое представление heave, surge, sway (0 – с обычным разрешением 0.01м; 1 – с высоким разрешением – heave 0.0001 м; surge, sway – 0.001 м
    /*1506..1506*/ unsigned char  Power_fft_HSS;             // Порог мощности спектра БПФ по ускорению, при котором пересчитываются параметры LL фильтра для heave
    /*1507..1507*/ unsigned char  GNSS_COM2_data_set;        // Вариант выходных данных приемника СНС: (0 – нет данных; 1 – raw GNSS data set; 2 – NMEA GGA, VTG, ZDA)
    /*1508..1509*/ short          dig_P9;                    // Калибровочный коэффициент датчика давления BMP280
    /*1510..1511*/ short          dig_P10;                   // Калибровочный коэффициент датчика давления BMP280 (резерв)
    /*1512..1512*/ unsigned char  Hs_wave;                   // =0 запретить расчет высоты волны =1 разрешить расчет высоты волны
    /*1513..1514*/ unsigned short t_INS_max_new;             // Максимально допустимое время автономной работы БИНС без коррекции от СНС, сек Новый параметр вместо t_INS_max для увеличения задаваемого времени
    /*1515..1515*/ unsigned char  CAN_bps;                   // Скорость выдачи данных CAN адаптером: (0 – 10K; 1 – 20K;2 – 50K; 3 – 100K; 4 – 125K; 5 – 250K; 6 – 500K; 7 – 1M)
    /*1516..1516*/ unsigned char  Use_CAN;                   // Задействовать (1) или нет(0) байт #2 в заголовке данных ИНС по формату “INS Minimal Data” для “Device identifier” CAN-сообщений
    /*1517..1517*/ unsigned char  CAN_dev_ID;                // “Device identifier” – изменяемая часть адреса CAN-сообщений
    /*1518..1518*/ unsigned char  k_Sigma_Ku2A;              // Порог для квадратичной формы невязки по курсу при использовании 2-х антенного приемника СНС
    /*1519..1520*/ unsigned short STD_fi_la_rtk;             // СКО шума измерения приемника СНС при определении широты и долготы в режиме RTK (m*100)
    /*1521..1522*/ unsigned short STD_h_rtk;                 // СКО шума измерения приемника СНС при определении высоты в режиме RTK (m*100)
    /*1523..1523*/ unsigned char  ms_pos_corr;               // Вариант коррекции ms_pos (0 – без коррекции от приемника, 1 – с коррекцией по времени полученному от приемника в логе Bestvel)
    /*1524..1524*/ unsigned char  ZUPT;                      // Параметры алгоритма ZUPT(0 - отключено; 1 (0x01) - стабилизация углов; 2 (0x10) - стабилизация координат; 3 (0x11) - стабилизация углов и координат)
    /*1525..1525*/ unsigned char  Vh_zupt;                   // Порог горизонтальной скорости для ZUPT, (m/s*100)
    /*1526..1526*/ unsigned char  Vv_zupt;                   // Порог вертикальной скорости для ZUPT, (m/s*100)
    /*1527..1527*/ unsigned char  Tv_zupt;                   // Постоянная времени фильтра НЧ фильтра для скорости СНС (sec*100)
    /*1528..1528*/ unsigned char  Use_mags;                  // Использовать (1) или нет(0) коррекцию ИНС по магнитометрам
    /*1529..1529*/ unsigned char  Output_Data_Variant;       // Modification of data formats INS, AHRS-II, IMU (0 – старый, 1 – изменение полей TS_gps, GNSS_info во всех форматах данных кроме “INS Sensors Data”
    /*1530..1530*/ unsigned char  MARK_switch;               // Mark inputs control switch (0 – DISABLE, 1 – ENABLE)
    /*1531..1531*/ unsigned char  MARK_polarity;             // Polarity of the pulse (0 – negative, 1 - positive)
    /*1532..1533*/ unsigned short MARK_timebias;             // An offset, in nanoseconds, to be applied to the time the mark input pulse occurs (default =0)
    /*1534..1535*/ unsigned short MARK_timeguard;            // A time period, in milliseconds, during which subsequent pulses after an initial pulse are ignored. (default: 4, minimum: 2)
    /*1536..1536*/ unsigned char  PPS_switch;                // PPS control switch (0 – ENABLE, 1 – DISABLE)
    /*1537..1537*/ unsigned char  PPS_polarity;              // Polarity of the pulse (0 – negative, 1 - positive)
    /*1538..1538*/ unsigned char  PPS_period;                // Period of the pulse in seconds( 0.05, 0.1, 0.2, 0.25, 0.5, 1.0, 2.0, 3.0,...20.0). Default=1.0.Для совместимости 0 = Default
    /*1539..1540*/ unsigned short PPS_pulse_width;           // Pulse width of the PPS signal in microseconds (default=1000)
    /*1541..1541*/ unsigned char  GNSS_COM3_data_rate;       // GNSS_COM3_data_rate log switch (0 – DISABLE, 1 – 1Hz, 2 – 2Hz, 3 – 4Hz,4 – 5Hz, 5 – 10Hz, 6 – 20Hz)
    /*1542..1542*/ unsigned char  GNSS_COM2_bps ;            // Baud rate com порта который выдает сырые данные СНС (0 – 115200, 1 –230400, 2 –460800, 3 – 921600 bps)
    /*1543..1543*/ unsigned char  Vh_cut;                    // Порог гориз. скорости для вычисления путевого угла (m/s * 10)
    /*1544..1544*/ unsigned char  KF_H_meas;                 // Вариант вектора измерений по курсу для ОФК (0 – по магнитометрам, 1 – по курсу AHRS, 2 – по курсу GPS)
    /*1545..1545*/ unsigned char  GNSS_corr_type  ;          // Тип коррекции GNSS (0 - No Correction, 1 – AUTO, 2 – SBAS, 3 – DGPS)
    /*1546..1546*/ unsigned char  GNSS_corr_format;          // Формат данных поправок (0 – AUTO,1 – RTCMv2, 2 – RTCMv3)
    /*1547..1547*/ unsigned char  GNSS_COM3_bps  ;           // Baud rate com порта который принимает поправки
    /*1548..1548*/ unsigned char  Power_fft_min;             // Порог мощности спектра БПФ при котором пересчитываются параметры LL фильтра для heave
    /*1549..1549*/ unsigned char  F_fft;                     // Частота использования БПФ (Гц*100) для пересчета параметров LL фильтра для heave
    /*1550..1550*/ unsigned char  Sa;                        // СКО порождающего шума акселерометра (м/с^3)*1e4
    /*1551..1552*/ unsigned short STD_fi_la;                 // СКО шума измерения приемника СНС при определении широты и долготы (m*100)
    /*1553..1554*/ unsigned short STD_h;                     // СКО шума измерения приемника СНС при опр-нии высоты (m*100)
    /*1555..1555*/ unsigned char  STD_Vh;                    // СКО шума приемника СНС при определении горизонтальной скорости движения (m/s*100)
    /*1556..1556*/ unsigned char  STD_Vv;                    // СКО шума приемника СНС при определении вертикальной скорости движения (m/s*100)
    /*1557..1557*/ unsigned char  STD_h_bar;                 // СКО шума измерения баровысотомера (m*100)
    /*1558..1558*/ unsigned char  kR_coord;                  // Коэффициент увеличения дисперсии шума по координатам
    /*1559..1559*/ unsigned char  kR_V;                      // Коэффициент увеличения дисперсии шума по скоростям
    /*1560..1560*/ unsigned char  kR_Ku;                     // Коэффициент увеличения дисперсии шума по курсу
    /*1561..1561*/ unsigned char  k_Sigma_coord;             // Порог для квадратичной формы невязки по координатам
    /*1562..1562*/ unsigned char  k_Sigma_V;                 // Порог для квадратичной формы невязки по скоростям
    /*1563..1563*/ unsigned char  k_Sigma_Ku;                // Порог для квадратичной формы невязки по курсу
    /*1564..1564*/ unsigned char  STD_fi_la_init;            // Нач.условия для эл-тов матрицы P0[0][0], P0[1][1]    ОФК (m*1000)
    /*1565..1565*/ unsigned char  STD_Vh_init;               // Нач.условия для эл-тов матрицы P0[2][2], P0[3][3]    ОФК (m/s*1000)
    /*1566..1566*/ unsigned char  Sw_init;                   // Нач.условия для эл-тов матрицы P0[7][7]… P0[9][9]  ОФК (deg/s/sqrt(Hz) *1000)
    /*1567..1567*/ unsigned char  Sa_init;                   // Нач.условия для эл-тов матрицы P0_1[0][0]  ОФК верт. (m/s2/sqrt(Hz) *1e4)
    /*1568..1568*/ unsigned char  Angl_var;                  // ИСОН выдает наружу углы ориентации – AHRS (0) или БИНС (1)
    /*1569..1569*/ unsigned char  t_INS_max;                 // Максимально допустимое время автономной работы БИНС без коррекции от СНС, сек
    /*1570..1575*/ short          ro_gps[3];                 // Положение антенны СНС относительно БИНС в осях объекта (m*100)
    /*1576..1581*/ short          ro_tp [3];                 // Положение расчетной точки Surge,Sway,Heave относительно AHRS в осях объекта, (m*100)
    /*1582..1582*/ unsigned char  fh_HP;                     // Частота ВЧ фильтра для heave, sway, surge (Гц * 100),fhss_LP = fh_HP
    /*1583..1584*/ unsigned short fh_LP;                     // Частота НЧ фильтра для heave, sway, surge (Гц * 100)
    /*1585..1585*/ unsigned char  h_bar_mode;                // Вид высоты, выдаваемой по NMEA
                                                             // 0= обычная барометрическая высота при p_zero=101325.0;
                                                             // 1= барометрическая высота с приведением начального значения к высоте по СНС или считанной из флеши;
                                                             // 2= heave
    /*1586..1586*/ unsigned char  baro_enabled;              // Разрешение использовать данные баровысотомера (1) или нет (0)
    /*1587..1587*/ unsigned char  GNSS_enabled;              // Разрешение использовать данные СНС (обычно =1 для ИСОН, и =0 для AHRS-II)

    /*1588..1588*/ unsigned char  Fgps;                      // Частота выдачи данных приемника СНС (Гц)
    /*1589..1590*/ short          AC1;                       // Калибровочный коэффициент датчика давления BMP180
    /*1591..1592*/ short          AC2;                       // Калибровочный коэффициент датчика давления BMP180
    /*1593..1594*/ short          AC3;                       // Калибровочный коэффициент датчика давления BMP180

    /*1595..1596*/ unsigned short AC4;                       // Калибровочный коэффициент датчика давления BMP180
    /*1597..1598*/ unsigned short AC5;                       // Калибровочный коэффициент датчика давления BMP180
    /*1599..1600*/ unsigned short AC6;                       // Калибровочный коэффициент датчика давления BMP180

    /*1601..1602*/ short          B1;                        // Калибровочный коэффициент датчика давления BMP180
    /*1603..1604*/ short          B2;                        // Калибровочный коэффициент датчика давления BMP180
    /*1605..1606*/ short          MB;                        // Калибровочный коэффициент датчика давления BMP180
    /*1607..1608*/ short          MC;                        // Калибровочный коэффициент датчика давления BMP180
    /*1609..1610*/ short          MD;                        // Калибровочный коэффициент датчика давления BMP180
    /*1611..1612*/ unsigned short QTmc_ii;                   // Stability: Tm_c_ii * 1000
    /*1613..1614*/ unsigned short QTmc_ij;                   // Stability: Tm_c_ij * 1000
    /*1615..1615*/ unsigned char  FlyZoneType;               // Тип зональной калибровки на лету: 0 - ручной (по введенному значению), 1 - по оптическому азимуту
    /*1616..1616*/ unsigned char  BoresightingCountSuccess;  // Необходимое количество набранных данных для успешной процедуры Boresighting в step2
    /*1617..1617*/ unsigned char  InitClbType;               // Start OptoWOM with selected Tm_c, Hm0 type
    /*1618..1619*/ unsigned short STmc_ii;                   // Initial Errors: Tm_c_ii * 100
    /*1620..1621*/ unsigned short STmc_ij;                   // Initial Errors: Tm_c_ij * 100
    /*1622..1623*/ unsigned short SHt0;                      // Initial Errors: Ht0
    /*1624..1625*/ unsigned short SErr;                      // Measurement Errors
    /*1626..1626*/ unsigned char  ISunMax;                   // Максимальное значение яркости Солнца
    /*1627..1627*/ unsigned char  IOutMin;                   // Минимальное значение яркости светлого поля вокруг пикселей Солнца
    /*1628..1628*/ unsigned char  SunPredict;                // Прогноз положения Солнца на картинке
    /*1629..1629*/ unsigned char  FramesAverage;             // Количество данных для осреднения в астрокомпасе
    /*1630..1631*/ unsigned short QHt0;                      // Stability: Ht0
    /*1632..1667*/ float          Tm_c_OptoWOM[3][3];        // factory Tm_c
    /*1668..1679*/ float          Hm0_OptoWOM[3];            // factory Hm0
    /*1680..1715*/ float          Tm_c_2D2T[3][3];           // last 2D-2T calibration Tm_c
    /*1716..1727*/ float          Hm0_2D2T[3];               // last 2D-2T calibration Hm0
    /*1728..1763*/ float          Tm_c_Z[3][3];              // last zone based calibrarion Tm_c
    /*1764..1775*/ float          Hm0_Z[3];                  // last zone based calibrarion Hm0
    /*1776..1811*/ float          Tm_c_AC[3][3];             // last auto calibration Tm_c
    /*1812..1823*/ float          Hm0_AC[3];                 // last auto calibration Hm0
    /*1824..1824*/ unsigned char  PLSFramesForOneFix;        // PLS: frames for one fix
    /*1825..1825*/ unsigned char  PLSLogicalLevelThreshold;  // PLS logical: level threshold
    /*1826..1827*/ unsigned short PLSLogicalCutOffThreshold; // PLS logical: cut off threshold
    /*1828..1829*/ unsigned short PLSDiffCutOffThreshold;    // PLS differential: cut off threshold
    /*1830..1869*/ float          ERIntrinsics_2[10];        // Параметры OptoWOM ER: Intrinsics левой боковой камеры
    /*1870..1870*/ unsigned char  CamClbModel_2;             // Тип модели калибровки левой боковой камеры камеры (0=arcant; 1=ratpoly1; 2=ratpoly2)
    /*1871..1909*/ unsigned char  ReservForOW[39];
    /*1910..1910*/ unsigned char  CWOM_time_delay;           // Параметры CWOM: задержка данных, мсек
    /*1911..1911*/ unsigned char  CWOM_rate;                 // Параметры CWOM: Measurement rate, Hz
    /*1912..1912*/ char           CamResolution;             // Резерв
    /*1913..1913*/ unsigned char  CamClbModel_1;             // Тип модели калибровки фронтальной камеры (0=arcant; 1=ratpoly1; 2=ratpoly2)
    /*1914..1914*/ unsigned char  CamBinning;                // Параметры ICube: Binning, =0 at binning 2x2; =1 at no binning
    /*1915..1915*/ unsigned char  CamClock;                  // Параметры ICube: Clock
    /*1916..1917*/ unsigned short CamExposureTarget;         // Параметры ICube: ExposureTarget
    /*1918..1919*/ unsigned short CamExposure;               // Параметры ICube: Exposure
    /*1920..1920*/ unsigned char  CamExposureAuto;           // Параметры ICube: ExposureAuto
    /*1921..1921*/ unsigned char  CamGain;                   // Параметры ICube: Gain
    /*1922..1922*/ unsigned char  CamBlacklevel;             // Параметры ICube: Blacklevel
    /*1923..1923*/ unsigned char  CamBlacklevelAuto;         // Параметры ICube: BlacklevelAuto
    /*1924..1924*/ unsigned char  CamGamma;                  // Параметры ICube: Gamma
    /*1925..1926*/ unsigned short CamContrast;               // Параметры ICube: Contrast
    /*1927..1927*/ unsigned char  CamBrightness;             // Параметры ICube: Brightness
    /*1928..2007*/ double         ERIntrinsics_1[10];        // Параметры OptoWOM ER: Intrinsics фронтальной камеры
    /*2008..2011*/ unsigned int   ICubeSN_1;                 // Серийный номер фронтальной ICube камеры
    /*2012..2015*/ unsigned int   ICubeSN_2;                 // Серийный номер левой боковой ICube камеры
    /*2016..2017*/ unsigned short Do_H;                      // Параметры OptoWOM ER: дисперсия шума оптического угла курса для ОФК, рад2 * 1E+8
    /*2018..2019*/ unsigned short count_optic_threshold_H;   // Параметры OptoWOM ER: порог для счетчика отсутствия данных от оптики
    /*2020..2021*/ unsigned short RefCovLim_H;               // Параметры OptoWOM ER: порог для ковариационной матрицы оптики, число*1E+8 (в ХАИ не использовалось, только в ER)
    /*2022..2023*/ unsigned short RMS_optic_threshold_H;     // Параметры OptoWOM ER: порог по СКО шума оптики, число*100
    /*2024..2025*/ unsigned short DUS_threshold_H;           // Параметры OptoWOM ER: порог по ДУС, град/сек
    /*2026..2026*/ unsigned char  optic_time_delay_H;        // Параметры OptoWOM ER: задержка данных, мсек
    /*2027..2027*/ unsigned char  RFlimit;                   // Порог для автоматического создания опорных кадров, град
    /*2028..2028*/ unsigned char  RFlimitAllowance;          // Порог для автоматического создания опорных кадров, %
    /*2029..2030*/ char           Reserved5[2];              // Резерв
    /*2031..2033*/ char           Extrinsics_1[3];           // 3 угла отклонения осей фронтальной камеры относ. OptoWOM, град*100
    /*2034..2039*/ short          Extrinsics_2[3];           // 3 угла отклонения осей левой боковой камеры относ. OptoWOM, град*100
    /*2040..2047*/ char           IDN[8];                    // Integrated device name
};

// LoadINSPar data structure as specified in INS ICD
// revision 2.9, section 6.3.4
struct short_prm_t
{
    unsigned short data_rate;
    unsigned short align_time;
    long mag_dec;
    long latitude, longitude, altitude;
    unsigned char year, month, day;
    short align_angles[3];
    short mount[3];
    short lever[3];
    unsigned char altitude_byte;
    char device_name[9];
    unsigned char baro_altimeter;
};

// converts LoadINSPar payload to short_prm_t struct; if pointer to struct
// is null, does nothing (note: uses little-endian byte ordering)
void payload2short_prm(struct short_prm_t *prm, const unsigned char payload[60])
{
    if (!prm || !payload) return;

    memset(prm->device_name, 0, sizeof(prm->device_name));
    memcpy(prm->device_name, payload + 50, 8);

    prm->data_rate = payload[0] | (payload[1] << 8);
    prm->align_time = payload[2] | (payload[3] << 8);
    prm->mag_dec = payload[4] | (payload[5] << 8) |
        (payload[6] << 16) | (payload[7] << 24);

    prm->latitude  = payload[8] | (payload[9] << 8) |
        (payload[10] << 16) | (payload[11] << 24);
    prm->longitude = payload[12] | (payload[13] << 8) |
        (payload[14] << 16) | (payload[15] << 24);
    prm->altitude  = payload[16] | (payload[17] << 8) |
        (payload[18] << 16) | (payload[19] << 24);

    prm->year = payload[20], prm->month = payload[21], prm->day = payload[22];

    prm->align_angles[0] = payload[23] | (payload[24] << 8);
    prm->align_angles[1] = payload[25] | (payload[26] << 8);
    prm->align_angles[2] = payload[27] | (payload[28] << 8);

    prm->mount[0] = payload[29] | (payload[30] << 8);
    prm->mount[1] = payload[31] | (payload[32] << 8);
    prm->mount[2] = payload[33] | (payload[34] << 8);

    prm->lever[0] = payload[35] | (payload[36] << 8);
    prm->lever[1] = payload[37] | (payload[38] << 8);
    prm->lever[2] = payload[39] | (payload[40] << 8);

    prm->altitude_byte = payload[41];
    prm->baro_altimeter = payload[58];
}

// does the opposite of the above function - converts short_prm_t struct
// to 60 byte payload
void struct2payload(const struct short_prm_t *prm, unsigned char payload[60])
{
    if (!prm) return;

    memset(payload, 0, 60);
    memcpy(payload + 50, prm->device_name, 8);

    payload[0] = prm->data_rate & 0xFF;
    payload[1] = prm->data_rate >> 8;

    payload[2] = prm->align_time & 0xFF;
    payload[3] = prm->align_time >> 8;

    payload[4] = prm->mag_dec & 0xFF;
    payload[5] = prm->mag_dec >> 8;
    payload[6] = prm->mag_dec >> 16;
    payload[7] = prm->mag_dec >> 24;

    payload[8] = prm->latitude & 0xFF;
    payload[9] = prm->latitude >> 8;
    payload[10] = prm->latitude >> 16;
    payload[11] = prm->latitude >> 24;

    payload[12] = prm->longitude & 0xFF;
    payload[13] = prm->longitude >> 8;
    payload[14] = prm->longitude >> 16;
    payload[15] = prm->longitude >> 24;

    payload[16] = prm->altitude & 0xFF;
    payload[17] = prm->altitude >> 8;
    payload[18] = prm->altitude >> 16;
    payload[19] = prm->altitude >> 24;

    payload[20] = prm->year;
    payload[21] = prm->month;
    payload[22] = prm->day;

    payload[23] = prm->align_angles[0] & 0xFF;
    payload[24] = prm->align_angles[0] >> 8;

    payload[25] = prm->align_angles[1] & 0xFF;
    payload[26] = prm->align_angles[1] >> 8;

    payload[27] = prm->align_angles[2] & 0xFF;
    payload[28] = prm->align_angles[2] >> 8;

    payload[29] = prm->mount[0] & 0xFF;
    payload[30] = prm->mount[0] >> 8;

    payload[31] = prm->mount[1] & 0xFF;
    payload[32] = prm->mount[1] >> 8;

    payload[33] = prm->mount[2] & 0xFF;
    payload[34] = prm->mount[2] >> 8;

    payload[35] = prm->lever[0] & 0xFF;
    payload[36] = prm->lever[0] >> 8;

    payload[37] = prm->lever[1] & 0xFF;
    payload[38] = prm->lever[1] >> 8;

    payload[39] = prm->lever[2] & 0xFF;
    payload[40] = prm->lever[2] >> 8;

    payload[41] = prm->altitude_byte;
    payload[58] = prm->baro_altimeter;
}

// prints payload to stdout with helpful labels
void print_payload(const unsigned char payload[60])
{
    printf("device name:");
    for (int i = 50; i < 58; ++i)
    {
        printf(" %02x", payload[i]);
    }
    printf("\ndata rate: %02x %02x\n", payload[0], payload[1]);
    printf("initial alignment time: %02x %02x\n",
            payload[2], payload[3]);
    printf("magnetic declination: %02x %02x %02x %02x\n",
            payload[4], payload[5], payload[6], payload[7]);
    printf("position: %02x %02x %02x %02x, %02x %02x "
                     "%02x %02x, %02x %02x %02x %02x\n",
            payload[8], payload[9], payload[10], payload[11],
            payload[12], payload[13], payload[14], payload[15],
            payload[16], payload[17], payload[18], payload[19]);
    printf("date: %02x/%02x/%02x\n", payload[20], payload[21], payload[22]);
    printf("alignment angles: <%02x %02x, %02x %02x, %02x %02x>\n",
        payload[23], payload[24], payload[25],
        payload[26], payload[27], payload[28]);
    printf("mounting lever: <%02x %02x, %02x %02x, %02x %02x>\n",
        payload[29], payload[30], payload[31],
        payload[32], payload[33], payload[34]);
    printf("lever arm: <%02x %02x, %02x %02x, %02x %02x>\n",
        payload[35], payload[36], payload[37],
        payload[38], payload[39], payload[40]);
    printf("altitude output: %02x\n", payload[41]);
    printf("baro enabled: %02x\n", payload[58]);
}

// prints short_prm_t struct to stdout
// note: values are printed in SI units, as opposed to the way they're
// stored in the data structure; for example, magnetic declination
// is expressed in degrees, rather than hundredths of degrees
void print_struct(struct short_prm_t prm)
{
    printf("device name: %s\n", prm.device_name);
    printf("data rate: %hu Hz\n", prm.data_rate);
    printf("initial alignment time: %hu seconds\n", prm.align_time);
    printf("magnetic declination: %0.2f degrees\n", prm.mag_dec/100.0);
    printf("position: %0.5f, %0.5f, %0.2f\n",
            prm.latitude/10000000.0,
            prm.longitude/10000000.0,
            prm.altitude/100.0);
    printf("date: %hu/%02hhu/%02hhu\n", 2000 + prm.year, prm.month, prm.day);
    printf("alignment angles: <%0.2f, %0.2f, %0.2f> degrees\n",
        prm.align_angles[0]/100.0,
        prm.align_angles[1]/100.0,
        prm.align_angles[2]/100.0);
    printf("mounting lever: <%0.2f, %0.2f, %0.2f> meters\n",
        prm.mount[0]/100.0, prm.mount[1]/100.0, prm.mount[2]/100.0);
    printf("lever arm: <%0.2f, %0.2f, %0.2f> meters\n",
        prm.lever[0]/100.0, prm.lever[1]/100.0, prm.lever[2]/100.0);
    printf("altitude output: %hhu\n", prm.altitude_byte);
    printf("baro enabled: %hhu\n", prm.baro_altimeter);
}

// converts user input, unsigned long, to the type
// used by fcntl.h, speed_t
speed_t int2speed_t(unsigned long baudrate)
{
    switch (baudrate)
    {
        case 9600: return B9600;
        case 19200: return B19200;
        case 38400: return B38400;
        case 57600: return B57600;
        case 115200: return B115200;
        case 230400: return B230400;
        case 460800: return B460800;
        case 500000: return B500000;
        case 576000: return B576000;
        case 921000: return B921600;
        case 1000000: return B1000000;
        case 1152000: return B1152000;
        case 1500000: return B1500000;
        case 2000000: return B2000000;
        case 2500000: return B2500000;
        case 3000000: return B3000000;
        case 3500000: return B3500000;
        case 4000000: return B4000000;
        default: return -1;
    }
}

const char* argument_error =
    "%s: invalid option -- '%s'\n"
    "type '%s --usage' for more info\n";

const char* usage_help =
    "usage: %s device [-p] [-r dr] [-i s] [-l lx ly lz] [-a h p r]\n"
    "  device: INS COM1 serial device path\n"
    "  [-n]: print INS serial number\n"
    "  [-p]: print INS params in plaintext\n"
    "  [-h]: print INS params in hex\n"
    "  dr: data rate of INS output, in Hz; must be multiple of 200 Hz\n"
    "  s: INS initial alignment time in seconds\n"
    "  lx ly lz: offset from imu to antenna, in meters\n"
    "  h p r: angle offset from vehicle orientation, in degrees\n";

// valid data rates for INS data frame output, in Hz
const unsigned char valid_rates[] = {1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 200};

// possible INS baudrates, in order of likelihood
const speed_t valid_bps[] =
    {B460800, B115200, B230400, B57600, B38400, B19200, B9600};

int main(int argc, char** argv)
{
    if (argc < 2) // first argument must be INS COM1 device
    {
        fprintf(stderr, "%s: must provide file path\n", argv[0]);
        return 1;
    }

    // special case: if first argument is "--usage", print the usage
    // help string to stderr
    if (strcmp(argv[1], "--usage") == 0)
    {
        printf(usage_help, argv[0]);
        return 0;
    }

    // open the LoadINSPar file; if can't open, return error
    int com1 = open(argv[1], O_RDWR | O_NOCTTY | O_NDELAY);
    if (com1 == -1)
    {
        fprintf(stderr, "%s: failed to open %s\n", argv[0], argv[1]);
        return 1;
    }

    // these flags indicate whether each flag has appeared in argv,
    // rate_flag for -r, init_flag for -i, etc. The default state is 0.
    unsigned char rate_flag = 0;
    unsigned char init_flag = 0;
    unsigned char lever_flag = 0;
    unsigned char angle_flag = 0;
    unsigned char print_flag = 0;
    unsigned char hex_flag = 0;
    unsigned char name_flag = 0;

    // if user provides arguments, they'll be stored here
    unsigned char rate_input;
    unsigned char init_input;
    double lever_input[3];
    double angle_input[3];

    for (int i = 2; i < argc; ++i) // process every element in argv
    {
        // data rate flag
        if (!strcmp(argv[i], "-r") | !strcmp(argv[i], "--rate"))
        {
            if (argc < i + 2)
            {
                fprintf(stderr, usage_help, argv[0]);
                return 1;
            }
            rate_input = atoi(argv[++i]);

            // this mess is required because only some data rates are allowed
            // by the INS; if an invalid data rate is provided by the user,
            // the program must return an error and a helpful message

            unsigned char num_of_rates = sizeof(valid_rates)/sizeof(valid_rates[0]);
            for (int j = 0; j < num_of_rates; ++j)
            {
                // check every valid rate; if the provided rate is one of the
                // valid ones, the program will use it

                if (rate_input == valid_rates[j])
                {
                    rate_flag = 1;
                }
            }
            if (!rate_flag) // if the provided rate is invalid...
            {
                fprintf(stderr, "%s: valid data rates are: ", argv[0]);

                // print every valid rate, as provided above main()
                for (int j = 0; j < num_of_rates; ++j)
                {
                    fprintf(stderr, "%hhu", valid_rates[j]);
                    if (j < num_of_rates - 1) fprintf(stderr, ", ");
                }
                fprintf(stderr, "\n");
                return 1;
            }
        }
        // init alignment time flag
        else if (!strcmp(argv[i], "-i") | !strcmp(argv[i], "--init"))
        {
            if (argc < i + 2)
            {
                fprintf(stderr, usage_help, argv[0]);
                return 1;
            }
            init_flag = 1;
            init_input = atoi(argv[++i]);
        }
        // lever arm flag
        else if (!strcmp(argv[i], "-l") | !strcmp(argv[i], "--lever"))
        {
            // verify that there are atleast 3 more arguments, because
            // -l expects lx, ly, and lz
            if (argc < i + 4)
            {
                fprintf(stderr, usage_help, argv[0]);
                return 1;
            }

            lever_flag = 1;
            lever_input[0] = atof(argv[++i]);
            lever_input[1] = atof(argv[++i]);
            lever_input[2] = atof(argv[++i]);

            // likewise, i is incremented by 3, because -l uses 3 arguments
        }
        // alignment angle flag
        else if (!strcmp(argv[i], "-a") | !strcmp(argv[i], "--angles"))
        {
            // -a is similar to -l in structure
            if (argc < i + 4)
            {
                fprintf(stderr, usage_help, argv[0]);
                return 1;
            }
            angle_flag = 1;
            angle_input[0] = atof(argv[++i]);
            angle_input[1] = atof(argv[++i]);
            angle_input[2] = atof(argv[++i]);
        }
        // print to stdout flag
        else if (!strcmp(argv[i], "-p") | !strcmp(argv[i], "--print"))
        {
            print_flag = 1;
        }
        // print hex to stdout flag
        else if (!strcmp(argv[i], "-h") | !strcmp(argv[i], "--hex"))
        {
            hex_flag = 1;
        }
        // print SN to stdout flag
        else if (!strcmp(argv[i], "-n") | !strcmp(argv[i], "--name"))
        {
            name_flag = 1;
        }
        else // if any argument is unexpected, throw argument error
        {
            fprintf(stderr, argument_error, argv[0], argv[i], argv[0]);
            return 1;
        }
    }

    // this flag will be 1 if any write commands were issued in argv; if not,
    // the program doesn't need to send a LoadINSPar command at all
    unsigned char write_flag = rate_flag | init_flag | lever_flag | angle_flag;

    { // setting serial device configuration
        /////////////////////////////////////////////
        // altering terminal serial device settings
        // warning: very hard to read
        struct termios settings;
        tcgetattr(com1, &settings);
        settings.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP |
            INLCR | IGNCR | ICRNL | IXON );
        settings.c_oflag &= ~(OPOST | ONLCR);
        settings.c_lflag &= ~(ISIG | ICANON | IEXTEN | ECHO | ECHOE |
            ECHOK | ECHOCTL | ECHOKE);
        settings.c_cflag &= ~(CSIZE | PARENB);
        settings.c_cflag |= CS8;
        settings.c_cc[VMIN] = 0;
        settings.c_cc[VTIME] = 0;
        tcsetattr(com1, TCSANOW, &settings);
        tcflush(com1, TCOFLUSH);
        /////////////////////////////////////////////
    }

    const unsigned char num_of_bps = sizeof(valid_bps)/sizeof(valid_bps[0]);
    int determined_bps = 0;

    for (int i = 0; i < num_of_bps && !determined_bps; ++i)
    {
        struct termios settings;
        tcgetattr(com1, &settings);
        cfsetspeed(&settings, valid_bps[i]);
        tcsetattr(com1, TCSANOW, &settings);
        tcflush(com1, TCOFLUSH);
        
        const unsigned char STOP_command[] =
            {0xAA, 0x55, 0, 0, 7, 0, 0xFE, 0x05, 0x01};
        const unsigned char GetBIT_command[] =
            {0xAA, 0x55, 0, 0, 7, 0, 0x1A, 0x21, 0x00};
        write(com1, STOP_command, sizeof(STOP_command));
        usleep(1*1000); // sleep for 100 ms
        unsigned char trash[10000];
        read(com1, trash, sizeof(trash));
        write(com1, GetBIT_command, sizeof(GetBIT_command));
        usleep(1.5*1000*1000); // sleep for 1.5 seconds
        unsigned char bit_response[14];
        int x = read(com1, bit_response, 14);
        
        printf("%02d:", i);
        for (int j = 0; j < x; ++j)
        {
            printf(" %02hhx", bit_response[j]);
        }
        printf("\n");

        unsigned short msg_check = bit_response[10] | (bit_response[11] << 8);
        unsigned short calc_check = 0;
        for (int j = 2; j < x - 2; ++j) calc_check += bit_response[j];

        if (x == 12 && msg_check == calc_check)
        {
            tcgetattr(com1, &settings);
            cfsetspeed(&settings, valid_bps[i]);
            tcsetattr(com1, TCSANOW, &settings);
            tcflush(com1, TCOFLUSH);
            determined_bps = 1;
        }
        write(com1, STOP_command, sizeof(STOP_command));
    }
    if (!determined_bps)
    {
        fprintf(stderr, "%s: error: could not determine baudrate\n", argv[0]);
        return 1;
    }
    
    { // changing COM1 baudrate
        unsigned char read_full_prm[] = {0xAA, 0x55, 0, 0, 7, 0, 0x0B, 0x12, 0};
        unsigned char write_full_prm[] =  {0xAA, 0x55, 0, 0, 7, 0, 0x0E, 0x15, 0};
        unsigned char change_com1_bps[] = {0xAA, 0x55, 0, 0, 7, 0, 0xC2, 0xC9, 0};
        int x = write(com1, read_full_prm, sizeof(read_full_prm));
        if (x != sizeof(read_full_prm))
        {
            fprintf(stderr, "%s: error: wrote %d/8 bytes\n", argv[0], x);
            return 1;
        }
        usleep(1*1000*1000); // sleep for 1.5 seconds
        unsigned char full_prm_frame[2056];
        x = read(com1, full_prm_frame, 2056);
        if (x != 2056)
        {
            fprintf(stderr, "%s: error: read %d/2056 bytes\n", argv[0], x);
            return 1;
        }
        
        /* for (int i = 0, line = 0; i < x; ++i) { if (line == 0)
            printf("%04x:", i); printf(" %02hhx", full_prm_frame[i]); ++line;
            if (line == 8) printf("  "); if (line == 16) { printf("\n"); line = 0; }
        } printf("\n"); */
        
        unsigned short check_calc = 0;
        for (int i = 2; i < x - 2; ++i)
        {
            check_calc += full_prm_frame[i];
        }
        unsigned short checksum = full_prm_frame[2054] |
                                 (full_prm_frame[2055] << 8);
        if (check_calc != checksum)
        {
            fprintf(stderr, "%s: error: checksum mismatch in "
                "full parameter file", argv[0]);
            return 1;
        }
        
        full_prm_frame[6 + 946] = 9;
        full_prm_frame[2] = 0;
        full_prm_frame[3] = 0;
        full_prm_frame[4] = 6;
        full_prm_frame[5] = 8;
        check_calc = 0;
        for (int i = 2; i < x - 2; ++i)
        {
            check_calc += full_prm_frame[i];
        }
        printf("checksum: %hu %hx", check_calc, check_calc);
        full_prm_frame[2054] = check_calc & 0xFF;
        full_prm_frame[2055] = check_calc >> 8;
        
        unsigned char dump[100];
        
        write(com1, write_full_prm, sizeof(write_full_prm));
        usleep(600*1000); // sleep 300 ms
        int r = read(com1, dump, sizeof(dump));
        printf("reply:");
        for (int i = 0; i < r; ++i)
        {
            printf(" %02hhx", dump[i]);
        }
        printf("\n");
        
        write(com1, full_prm_frame, sizeof(full_prm_frame));
        usleep(600*1000); // sleep 300 ms
        r = read(com1, dump, sizeof(dump));
        printf("reply:");
        for (int i = 0; i < r; ++i)
        {
            printf(" %02hhx", dump[i]);
        }
        printf("\n");
        
        write(com1, change_com1_bps, sizeof(change_com1_bps));
        usleep(600*1000); // sleep 300 ms
        r = read(com1, dump, sizeof(dump));
        printf("reply:");
        for (int i = 0; i < r; ++i)
        {
            printf(" %02hhx", dump[i]);
        }
        printf("\n");
    }
    
    
    // at this point the command line arguments are processed and the program
    // will have exited if any were invalid.

    // this block reads the entire ReadINSPar message and verifies that
    // the message structure is as expected, but only keeps the payload
    unsigned char payload[60];
    {
        const unsigned char ReadINSPar_command[] =
            {0xAA, 0x55, 0, 0, 7, 0, 0x41, 0x48, 0};
        unsigned char header[6], checksum[2];

        int x = write(com1, ReadINSPar_command, sizeof(ReadINSPar_command));
        if (x != sizeof(ReadINSPar_command))
        {
            fprintf(stderr, "%s: error sending ReadINSPar command "
                            "(%d bytes written)\n", argv[0], x);
            return 1;
        }
        usleep(500*1000); // wait for 500 milliseconds
        x = read(com1, header, sizeof(header)); // read the header
        x += read(com1, payload, sizeof(payload)); // read the payload
        x += read(com1, checksum, sizeof(checksum)); // checksum

        // TODO: verify the message contents

        if (x != sizeof(header) + sizeof(payload) + sizeof(checksum))
        {
            fprintf(stderr, "%s: error receiving ReadINSPar message "
                            "(%d bytes read)\n", argv[0], x);
            return 1;
        }
    }

    // take the payload and convert to usable primitives
    struct short_prm_t dat;
    payload2short_prm(&dat, payload);

    // if the user enabled any flags, assign the appropriate data to the struct
    if (rate_flag) dat.data_rate = rate_input;
    if (init_flag) dat.align_time = init_input;
    if (lever_flag)
    {
        dat.lever[0] = lever_input[0]*100;
        dat.lever[1] = lever_input[1]*100;
        dat.lever[2] = lever_input[2]*100;
    }
    if (angle_flag)
    {
        dat.align_angles[0] = angle_input[0]*100;
        dat.align_angles[1] = angle_input[1]*100;
        dat.align_angles[2] = angle_input[2]*100;
    }
    if (print_flag) print_struct(dat);
    if (hex_flag) print_payload(payload);
    if (name_flag) printf("%s\n", dat.device_name);

    // if no write flags are enabled, exit here
    if (!write_flag) return 0;

    // convert the struct back to a byte payload to prepare to send
    struct2payload(&dat, payload);

    const unsigned char command[] = {0xAA, 0x55, 0, 0, 7, 0, 0x40, 0x47, 0};
    const unsigned char header[] = {0xAA, 0x55, 1, 0, 0x42, 0};
    unsigned short checksum = 1 + 0x42;
    for (int i = 0; i < 60; ++i)
    {
        checksum += payload[i];
    }
    const unsigned char checksum_bytes[] = {checksum & 0xFF, checksum >> 8};
    unsigned char combined[68];
    memcpy(combined, header, sizeof(header));
    memcpy(combined + sizeof(header), payload, sizeof(payload));
    memcpy(combined + sizeof(header) + sizeof(payload),
        checksum_bytes, sizeof(checksum_bytes));

    int n = write(com1, command, sizeof(command));
    usleep(200*1000); // wait 200 milliseconds
    n += write(com1, combined, sizeof(combined));
    if (n < sizeof(combined))
    {
        fprintf(stderr, "%s: failed to write all bytes "
            "(%d written)\n", argv[0], n);
    }

    // TODO: verify checksum match

    return 0;
}
